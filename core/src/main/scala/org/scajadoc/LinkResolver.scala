package org.scajadoc

import collection.mutable
import io.Source
import java.net.URL
import tools.nsc.doc.model.{NoDocTemplate, TemplateEntity, DocTemplateEntity}

/**
 * Utility class resolving links to documentation for external and
 * internal dependencies.
 *
 * Internal references are classes whose documentation is being generated
 * during a Scajadoc run.
 *
 * External references are classes whose documentation is not being generated
 * during a Scajadoc run. Links in the documentation to those classes are said
 * to be external references or external links. Link option requires
 * that a file named package-list, which is generated by Javadoc (or Scajadoc) tool
 * exist at the URL specified with -link. The package-list file is a simple file that
 * lists the names of packages documented at that location. LinkResolver will not check
 * if documentation for classes from packages enlisted in package-list exists at specified
 * location.
 *
 * @author Filip Rogaczewski
 *
 */
object linkResolver {

   private val linksCache = new mutable.HashMap[DocTemplateEntity, Option[Link]]

   /**
    * Retrieves links specified in package-list files of the external dependencies.
    */
   def getLinksToExternalDependencies() = {
      def getPackageList(link : String) : Source = Source.fromURL(new URL(link + settings.PACKAGE_LIST_FILE))
      val links = new mutable.HashMap[String, String]
      settings.links.foreach(link => {
         getPackageList(link).getLines.foreach(packageName => links += (packageName -> link))
      })
      links
   }

   lazy val linksToExternalDependencies : mutable.Map[String, String] = getLinksToExternalDependencies

   def resolve(template : TemplateEntity) : Option[Link] = {
      template match {
         case dt : DocTemplateEntity => resolve(dt)
         case nt : NoDocTemplate => resolve(nt)
      }
   }

   /**
    * Resolves and returns link to the template. For instance if the
    * template passed is java.lang.String the result would be link
    * to http://download.oracle.com/javase/6/docs/api/java/lang/String. 
    */
   private def resolve(template : DocTemplateEntity) : Option[Link] = {
      linksCache.get(template) match {
         case Some(link) => link
         case None => {
            val link = makeLink(template)
            linksCache += (template -> link)
            link
         }
      }
   }

   /**
    * NoDocTemplate represents classes like scala.Any, scala.ScalaObject, java.lang.Object, etc.
    * Those classes are almost always in external dependencies, therefore external link is created.
    */
   private def resolve(template : NoDocTemplate) : Option[Link] = {
      externalLink(template, classpathCache(template))
   }

   /**
    * Returns link to the template. 
    */
   private def makeLink(template : DocTemplateEntity) : Option[Link] = {
      /**
       * Returns true if the template was generated during this Scajadoc run.
       */
      def isInternal(template : DocTemplateEntity) : Boolean = {
         template.sourceUrl match {
            case Some(e) => true
            case None => false
         }
      }
      val classpath = classpathCache(template)
      if (isInternal(template)) {
         internalLink(template, classpath)
      } else {
         externalLink(template, classpath)
      }
   }

   /**
    * Returns a link to the API of the template generated by this Scajadoc run. 
    */
   private def internalLink(template : DocTemplateEntity, classpath : Classpath) : Option[Link] = {
      Some(Link(settings.outdir.value + classpath.packageFilePath, template.name + settings.OUTPUT_FORMAT))
   }

   /**
    * Returns a link to the API of the dependency's template.
    */
   private def externalLink(template : TemplateEntity, classpath : Classpath) : Option[Link] = {
      val externalApi = linksToExternalDependencies.get(classpath.packageCanonicalPath)
      externalApi match {
         case Some(extApiLink) => Some(Link(extApiLink + classpath.packageFilePath, template.name + settings.OUTPUT_FORMAT))
         case None => None
      }
   }

}

case class Link(absolute : String, filename : String) {
   def relative(from : String) : String = ""
   def absoluteLink() : String = absolute + "/" + filename
}